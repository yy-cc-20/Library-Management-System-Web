import { Injectable } from '@angular/core';
import { Book } from './book';
import { Category } from './category';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root',
})
export class BookService {
  categoryList: Category[] = [];
  bookList: Book[] = [];

  // built-in json server api
  //bookApi = 'http://localhost:3000/bookList';
  //categoryApi = 'http://localhost:3000/categoryList';

  // .net api server I created
  bookApi = 'https://localhost:7030/api/book';
  categoryApi = 'https://localhost:7030/api/category';

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };
  constructor(private http: HttpClient)
  { }

  getCategoryList(): Observable<Category[]> {
    return this.http.get<any[]>(this.categoryApi)
      .pipe(
        map((response: any[]) => {
          return response.map((item: any) => ({
            id: item.id,
            name: item.name,
          }));
        }),
        tap(_ => console.log('fetched categories')),
        catchError(this.handleError<any[]>('getCategoryList', []))
      );
  }

  getBookList(): Observable<Book[]> {
    return this.http.get<any>(this.bookApi).pipe(
      map(response => {
        // mapping serialzied json object retrieve from backend api
        const objectMap = new Map<string, any>();

        response.$values.forEach((item: any) => {
          if (item.$id) {
            objectMap.set(item.$id, item);

            if (item.category && item.category.$id) 
              objectMap.set(item.category.$id, item.category);
          }
        });

        const books: Book[] = response.$values.map((item: any) => {
          if (item.$ref) {
            item = objectMap.get(item.$ref);
          }

          if (item.category && item.category.$ref) 
            item.category = objectMap.get(item.category.$ref);            

          return {
            id: item.id,
            name: item.name,
            author: item.author,
            category_id: item.category_Id,
            category: item.category ? {
              id: item.category.id,
              name: item.category.name
            } : null
          };
        });

        return books;
      }),
      tap(_ => console.log('fetched books')),
      catchError(this.handleError<Book[]>('getBooks', []))
    );
  }

  getBook(id: string): Observable<Book> {
    const url = `${this.bookApi}/${id}`;
    return this.http.get<any>(url)
      .pipe(
        map((response: any) => {
          // Assuming you're getting a single book object in the response
          return {
            id: response.id,
            name: response.name,
            author: response.author, 
            category_id: response.category_Id, 
            category: response.category ? {
              id: response.category.id,
              name: response.category.name
            } : null  
          } as Book; // Type assertion to ensure it's a Book object
        }),
        tap(_ => console.log(`fetched book id=${id}`)),
        catchError(this.handleError<Book>(`getBook id=${id}`))
    );
  }

  updateBook(book: Book): Observable<any> {
    const editedBook = {
      id: book.id,
      name: book.name,
      author: book.author,
      category_id: book.category_id
    };

    const url = `${this.bookApi}/${editedBook.id}`; 

    return this.http.put(url, editedBook, this.httpOptions).pipe(
      tap(_ => console.log(`updated book id=${editedBook.id}`)),
      catchError(this.handleError<any>('updateBook'))
    );
  }

  addBook(bookName: string, authorName: string, categoryId: string): Observable<Book> {
    const newBook = {
      // id will be generated by server
      name: bookName,
      author: authorName,
      category_id: categoryId // Adjusting to match the expected payload structure
    };
    return this.http.post<any>(this.bookApi, newBook, this.httpOptions).pipe(
      tap((newBook: Book) => console.log(`added book w/ id=${newBook.id}`)),
      catchError(this.handleError<Book>('addBook'))
    );
  }

  deleteBook(id: string): Observable<Book> {
    const url = `${this.bookApi}/${id}`;

    return this.http.delete<Book>(url, this.httpOptions).pipe(
      tap(_ => console.log(`deleted book id=${id}`)),
      catchError(this.handleError<Book>('deleteBook'))
    );
  }

  searchBooks(term: string): Observable<Book[]> {
    if (!term.trim()) {
      return of([]);
    }
    return this.http.get<Book[]>(`${this.bookApi}/?name=${term}`).pipe(
      tap(x => x.length ?
        console.log(`found books matching "${term}"`) :
        console.log(`no books matching "${term}"`)),
      catchError(this.handleError<Book[]>('searchBooks', []))
    );
  }
  /**
 * Handle Http operation that failed.
 * Let the app continue.
 *
 * @param operation - name of the operation that failed
 * @param result - optional value to return as the observable result
 */
  private handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      console.log(`${operation} failed: ${error.message}`);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  //categoryList: Category[] = [
  //  {
  //    "id": Guid.parse("72a17923-04a6-494b-9d3c-2c0cb161434c"),
  //    "name": "Romance"
  //  },
  //  {
  //    "id": Guid.parse("289ac3de-1cf3-4a0d-8795-f6e9b48b9ddb"),
  //    "name": "Fiction"
  //  },
  //  {
  //    "id": Guid.parse("f5cc7950-1491-467e-9745-58a30b1e8304"),
  //    "name": "Mystery"
  //  },
  //  {
  //    "id": Guid.parse("4cf3922a-76b7-4b5d-83e3-59b2bc2a779f"),
  //    "name": "Science Fiction"
  //  },
  //  {
  //    "id": Guid.parse("a6b1b4f1-66fb-4a6c-b006-610530f90561"),
  //    "name": "Historical Fiction"
  //  }
  //];

  //bookList: Book[] = [
  //  {
  //    "id": Guid.parse("2062c57a-a212-41b3-803e-85402f2d79b9"),
  //    "name": "Pride and Prejudice",
  //    "author": "Jane Austen",
  //    "category": {
  //      "id": Guid.parse("72a17923-04a6-494b-9d3c-2c0cb161434c"),
  //      "name": "Romance"
  //    }
  //  },
  //  {
  //    "id": Guid.parse("2c1541b8-3a93-47bf-9ab7-fbe807bdf68d"),
  //    "name": "The Great Gatsby",
  //    "author": "F. Scott Fitzgerald",
  //    "category": {
  //      "id": Guid.parse("289ac3de-1cf3-4a0d-8795-f6e9b48b9ddb"),
  //      "name": "Fiction"
  //    }
  //  },
  //  {
  //    "id": Guid.parse("37ad38a5-0509-4472-ac2f-3df5b3aa5ec7"),
  //    "name": "And Then There Were None",
  //    "author": "Agatha Christie",
  //    "category": {
  //      "id": Guid.parse("f5cc7950-1491-467e-9745-58a30b1e8304"),
  //      "name": "Mystery"
  //    }
  //  },
  //  {
  //    "id": Guid.parse("50a77a02-c363-473a-a3ad-1959dd49c9cc"),
  //    "name": "The Hitchhiker's Guide to the Galaxy",
  //    "author": "Douglas Adams",
  //    "category": {
  //      "id": Guid.parse("4cf3922a-76b7-4b5d-83e3-59b2bc2a779f"),
  //      "name": "Science Fiction"
  //    }
  //  },
  //  {
  //    "id": Guid.parse("608562c5-0e28-4f15-bab7-3406173c3bed"),
  //    "name": "The Book Thief",
  //    "author": "Markus Zusak",
  //    "category": {
  //      "id": Guid.parse("a6b1b4f1-66fb-4a6c-b006-610530f90561"),
  //      "name": "Historical Fiction"
  //    }
  //  }
  //];
  //constructor() { }

  //getCategoryList(): Category[] {
  //  return this.categoryList;
  //}

  //getBookList(): Book[] {
  //  return this.bookList;
  //}

  //getBook(id: Guid): Book | undefined {
  //  return this.bookList.find(book => book.id.equals(id));
  //}

  //getCategory(id: Guid): Category | undefined {
  //  return this.categoryList.find(category => category.id.equals(id));
  //}

  //addBook(bookName: string, authorName: string, categoryId: Guid) {
  //   const book = {
  //    id: Guid.create(),
  //    name: bookName,
  //    author: authorName,
  //    category: this.getCategory(categoryId) as Category,
  //  };
  //  this.bookList.push(book);
  //}

  //deleteBook(id: Guid) {
  //  this.bookList = this.bookList.filter(book => !book.id.equals(id));
  //}

  //editBook(id: Guid, bookName: string, authorName: string, categoryId: Guid) {
  //  var book = this.getBook(id);
  //  if (book !== undefined) {
  //    console.log(book);
  //    book.name! = bookName;
  //    book.author! = authorName;
  //    var category = this.getCategory(categoryId);
      
  //    if (category !== undefined) {
  //      book.category! = category;
  //    }
        
  //  }
  //}
}
